import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Booking, Status } from 'src/bookings/entities/booking.entity';
import { Role, User } from 'src/users/entities/user.entity';
import { Driver } from 'src/driver/entities/driver.entity';
import { PaymentMethod } from 'src/payment-method/entities/payment-method.entity';
import { Review } from 'src/review/entities/review.entity';
import { AnalyticsService } from 'src/analytics/analytics.service';
import { RoleSwitchingService } from 'src/users/role-switching.service';

@Injectable()
export class ChatbotService {
  private readonly logger = new Logger(ChatbotService.name);
  private conversationContext = new Map<number, any[]>();

  constructor(
    @InjectRepository(Booking)
    private readonly bookingRepository: Repository<Booking>,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(PaymentMethod)
    private readonly paymentMethodRepository: Repository<PaymentMethod>,
    @InjectRepository(Driver)
    private readonly driverRepository: Repository<Driver>,
    @InjectRepository(Review)
    private readonly reviewRepository: Repository<Review>,
    private readonly analyticsService: AnalyticsService,
    private readonly roleSwitchingService: RoleSwitchingService,
  ) {}

  async chat(userId: number, message: string): Promise<string> {
    try {
      this.logger.log(`Chat request from user ${userId}: ${message}`);
      
      this.addToContext(userId, { role: 'user', content: message, timestamp: new Date() });

      const lowerMessage = message.toLowerCase().trim();
      
      const intent = this.detectIntent(lowerMessage, userId);
      let response: string;

      switch (intent) {
        case 'urgentBooking':
          response = await this.handleUrgentBookingRequest(userId, message);
          break;
        case 'locationBooking':
          response = await this.handleLocationBasedBooking(userId, message);
          break;
        case 'booking':
          response = await this.handleBookingQuery(userId);
          break;
        case 'newBooking':
          response = await this.handleNewBookingInstructions(userId);
          break;
        case 'payment':
          response = await this.handlePaymentQuery(userId);
          break;
        case 'review':
          response = await this.handleReviews(userId);
          break;
        case 'profile':
          response = await this.handleProfile(userId);
          break;
        case 'help':
          response = await this.handleHelpQuery(userId);
          break;
        case 'cancel':
          response = await this.handleCancelBooking(userId);
          break;
        case 'greeting':
          response = await this.handleGreeting(userId);
          break;
        case 'analytics':
          response = await this.handleAnalytics(userId, lowerMessage);
          break;
        case 'system':
          response = await this.handleSystemStatus();
          break;
        default:
          response = await this.handleContextualResponse(userId, message);
      }

      this.addToContext(userId, { role: 'assistant', content: response, timestamp: new Date() });

      return response;
    } catch (error) {
      this.logger.error(`Error processing chat for user ${userId}:`, error);
      return this.getErrorResponse();
    }
  }

  private async handleUrgentBookingRequest(userId: number, message: string): Promise<string> {
    const locations = this.extractLocations(message);
    
    let response = `üö® **I'll help you get a ride right away!**\n\n`;
    
    if (locations.from && locations.to) {
      response += `üìç **Route Detected:**\n`;
      response += `üö© From: ${locations.from}\n`;
      response += `üéØ To: ${locations.to}\n\n`;
      
      response += `**üöó Quick Booking Options:**\n`;
      response += `üü¢ [Book Ride Now](/create?from=${encodeURIComponent(locations.from)}&to=${encodeURIComponent(locations.to)})\n`;
      response += `üì± [Emergency Booking](/emergency-booking?from=${encodeURIComponent(locations.from)}&to=${encodeURIComponent(locations.to)})\n\n`;
    } else {
      response += `**Let me help you book a ride:**\n`;
      response += `üöó [Start Booking Process](/create)\n`;
    }
    
    response += `**‚ö° Immediate Actions:**\n`;
    response += `üÜò Emergency Contact: 0700-Rideshare\n`;
    response += `üí¨ Live Support: Type "help" for immediate assistance\n\n`;
    
    response += `**üí° Tip:** For fastest service, share your exact location and destination!`;
    
    return response;
  }

  private async handleLocationBasedBooking(userId: number, message: string): Promise<string> {
    const locations = this.extractLocations(message);
    
    let response = `üó∫Ô∏è **Route Planning Assistant**\n\n`;
    
    if (locations.from && locations.to) {
      response += `**üìç Your Journey:**\n`;
      response += `üö© From: ${locations.from}\n`;
      response += `üéØ To: ${locations.to}\n\n`;
      
      response += `**üìä Journey Details:**\n`;
      response += `‚è±Ô∏è Estimated Time: 45-60 minutes\n`;
      response += `üí∞ Estimated Fare: $ 8-12\n`;
      response += `üöó Available Vehicles: Economy, Comfort\n\n`;
      
      response += `**üöÄ Book Your Ride:**\n`;
      response += `üü¢ [Book Now](/create?from=${encodeURIComponent(locations.from)}&to=${encodeURIComponent(locations.to)})\n`;
      response += `üë• [Shared Ride](/share?from=${encodeURIComponent(locations.from)}&to=${encodeURIComponent(locations.to)})\n\n`;
    } else {
      response += `I can help you plan your journey! Please provide:\n\n`;
      response += `üìç **Your current location** (e.g., "I'm in Thika")\n`;
      response += `üéØ **Your destination** (e.g., "need to get to Nairobi CBD")\n\n`;
      response += `üöó [Start Booking](/create) | üí¨ Type your journey details\n\n`;
    }

    response += `üì± [Download Mobile App](/landing)`;
    
    return response;
  }

  private extractLocations(message: string): { from?: string, to?: string } {
    const lowerMessage = message.toLowerCase();
    
    let from: string | undefined;
    let to: string | undefined;
    
    // Try to extract "from" location
    if (lowerMessage.includes('i\'m in') || lowerMessage.includes('stuck in') || lowerMessage.includes('i\'m at')) {
      const fromMatch = lowerMessage.match(/(?:i'm in|stuck in|i'm at)\s+([^,\s]+(?:\s+[^,\s]+)*?)(?:\s+(?:how|and|need|to)|$)/i);
      if (fromMatch) {
        from = fromMatch[1].trim();
      }
    }
    
    // Try to extract "to" location
    if (lowerMessage.includes('get to') || lowerMessage.includes('go to') || lowerMessage.includes('to nairobi')) {
      const toMatch = lowerMessage.match(/(?:get to|go to|to)\s+([^,\s]+(?:\s+[^,\s]+)*?)(?:\s|$)/i);
      if (toMatch) {
        to = toMatch[1].trim();
      }
    }
    
    return { from, to };
  }

  resetConversation(userId: number): void {
    this.conversationContext.delete(userId);
    this.logger.log(`Conversation reset for user ${userId}`);
  }

  private addToContext(userId: number, message: any): void {
    if (!this.conversationContext.has(userId)) {
      this.conversationContext.set(userId, []);
    }
    const context = this.conversationContext.get(userId);
    if (context) {
      context.push(message);
      if (context.length > 10) {
        context.shift();
      }
    }
  }

  private detectIntent(message: string, userId: number): string {
    const lowerMessage = message.toLowerCase();
    
    // Priority 1: Emergency/Urgent situations
    if (this.isUrgentRequest(lowerMessage)) {
      return 'urgentBooking';
    }
    
    // Priority 2: Location-based booking requests
    if (this.isLocationBasedBooking(lowerMessage)) {
      return 'locationBooking';
    }
    
    // Priority 3: Specific booking requests
    if (this.isSpecificBookingRequest(lowerMessage)) {
      return 'newBooking';
    }

    const intents = {
      booking: ['booking', 'ride', 'trip', 'book', 'schedule'],
      payment: ['payment', 'pay', 'bill', 'charge', 'refund'],
      driver: ['driver', 'location', 'where', 'pickup', 'drop'],
      review: ['review', 'rating', 'feedback', 'rate'],
      profile: ['profile', 'account', 'settings', 'me'],
      help: ['help', 'support', 'assist', 'what can you do'],
      cancel: ['cancel', 'stop', 'delete', 'remove'],
      greeting: ['hello', 'hi', 'hey', 'good morning', 'good afternoon', 'good evening'],
      analytics: ['analytics', 'stats', 'statistics', 'dashboard', 'earnings', 'performance'], 
      system: ['system', 'status', 'health', 'active drivers', 'active bookings'],
      newBooking: ['book a ride', 'new ride', 'create booking', 'need a ride', 'book now'],
      roleSwitching: ['switch to driver', 'become driver', 'switch to customer', 'customer mode', 'driver mode', 'change role', 'my role'],
    };

    // Only treat as greeting if it's JUST a greeting (not mixed with requests)
    if (this.isPureGreeting(lowerMessage)) {
      return 'greeting';
    }

    for (const [intent, keywords] of Object.entries(intents)) {
      if (keywords.some(keyword => lowerMessage.includes(keyword))) {
        return intent;
      }
    }

    return 'default';
  }

  private isUrgentRequest(message: string): boolean {
    const urgentKeywords = [
      'stuck', 'stranded', 'emergency', 'urgent', 'need help', 'help me',
      'lost', 'trapped', 'can\'t get', 'no way', 'desperate'
    ];
    
    const locationKeywords = [
      'how do i get to', 'how to get to', 'get me to', 'take me to',
      'i need to go to', 'i\'m in', 'i\'m stuck in', 'i\'m at'
    ];
    
    return urgentKeywords.some(keyword => message.includes(keyword)) ||
           locationKeywords.some(keyword => message.includes(keyword));
  }

  private isLocationBasedBooking(message: string): boolean {
    const locationPatterns = [
      'from .+ to .+', 'get to .+', 'go to .+', 'travel to .+',
      'i\'m in .+ need to get to', 'how do i get from .+ to .+'
    ];
    
    // Check for common Kenyan locations
    const kenyanLocations = [
      'nairobi', 'thika', 'kiambu', 'nakuru', 'mombasa', 'kisumu',
      'eldoret', 'cbd', 'westlands', 'karen', 'lavington', 'kasarani'
    ];
    
    return locationPatterns.some(pattern => {
      const regex = new RegExp(pattern, 'i');
      return regex.test(message);
    }) || kenyanLocations.some(location => message.includes(location));
  }

  private isSpecificBookingRequest(message: string): boolean {
    return message.includes('book a ride') || 
           message.includes('new ride') || 
           message.includes('create booking') || 
           message.includes('need a ride') || 
           message.includes('book now');
  }

  private isPureGreeting(message: string): boolean {
    const greetingWords = ['hello', 'hi', 'hey', 'good morning', 'good afternoon', 'good evening'];
    const words = message.split(' ');
    
    // If message is only 1-3 words and contains greeting, it's pure greeting
    if (words.length <= 3) {
      return greetingWords.some(greeting => message.includes(greeting));
    }
    
    return false;
  }

  private async handleBookingQuery(userId: number): Promise<string> {
    const bookings = await this.bookingRepository.find({
      where: { user: { userId: userId } }, 
      order: { pickup_time: 'DESC' },
      take: 5,
      relations: ['user', 'driver'],
    });

    if (bookings.length === 0) {
      return this.formatNoBookingsResponse();
    }

    return this.formatBookingsResponse(bookings);
  }

  private formatNoBookingsResponse(): string {
    return `üöó **Ready to Book Your First Ride?**

No bookings found yet.

**Quick Actions:**
üÜï Create New Booking: /create
üìã Browse Available Rides: /bookings

**Need Help?**
üí¨ Type "help" for assistance
üìû Contact Support: /support`;
  }

  private formatBookingsResponse(bookings: any[]): string {
    let response = `üìã **Your Recent Bookings**\n\n`;
    
    bookings.forEach((booking, index) => {
      const statusEmoji = this.getStatusEmoji(booking.status);
      const locationFrom = this.formatLocation(booking.start_latitude, booking.start_longitude);
      const locationTo = this.formatLocation(booking.end_latitude, booking.end_longitude);
      
      response += `**${index + 1}. Booking #${booking.id}** ${statusEmoji}\n`;
      response += `üìç From: ${locationFrom}\n`;
      response += `üìç To: ${locationTo}\n`;
      response += `üí∞ Fare: $${booking.fare || 0}\n`;
      response += `üîó View Details: /bookings/${booking.id}\n`;
      response += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
    });

    response += `**Quick Actions:**\n`;
    response += `üìã View All Bookings: /bookings\n`;
    response += `üÜï Book Another Ride: /create\n`;
    response += `üìä View Analytics: /analytics`;

    return response;
  }

  private async handleNewBookingInstructions(userId: number): Promise<string> {
    return `üöó **How to Book a Ride** - Step by Step Guide

**Step 1: Set Your Pickup Location**
üìç Enter your current location or choose from saved addresses

**Step 2: Choose Your Destination**
üéØ Type in where you want to go

**Step 3: Select Ride Type**
üöô Economy, Comfort, or Premium options available

**Step 4: Review & Confirm**
üí∞ Check fare estimate and driver details
‚úÖ Confirm your booking

**Step 5: Track Your Ride**
üì± Watch your driver approach in real-time

**Ready to Book?**
üÜï Start New Booking: /create
üì± Use Mobile App: Download from app store

**Need Help?**
üí¨ Type "help" for more assistance
üìû Call Support: /support`;
  }

  private getStatusEmoji(status: string): string {
    const statusEmojis = {
      'requested': 'üïí',
      'confirmed': '‚úÖ',
      'in_progress': 'üöó',
      'completed': 'üéâ',
      'cancelled': '‚ùå',
      'pending': '‚è≥'
    };
    return statusEmojis[status.toLowerCase()] || 'üìù';
  }

  private formatLocation(lat: number, lng: number): string {
    return `${lat.toFixed(4)}, ${lng.toFixed(4)}`;
  }

  private async handlePaymentQuery(userId: number): Promise<string> {
    const paymentMethods = await this.paymentMethodRepository.find({
      where: { user: { userId: userId } },
      relations: ['user'],
    });

    if (paymentMethods.length === 0) {
      return `üí≥ **Payment Methods**

No payment methods saved yet.

**Get Started:**
üí≥ Add Payment Method: /payment/bookingId
üí° Tip: Add a payment method for faster bookings!

**Accepted Methods:**
üí≥ Credit/Debit Cards
üì± Mobile Payments
üí∞ Paypal`;
    }

    let response = `üí≥ **Your Payment Methods**\n\n`;
    
    paymentMethods.forEach((pm, index) => {
      const defaultBadge = pm.is_default ? ' üåü (Default)' : '';
      const typeEmoji = this.getPaymentTypeEmoji(pm.payment_type);
      
      response += `${index + 1}. ${typeEmoji} **${pm.payment_type}**${defaultBadge}\n`;
    });

    return response;
  }

  private getPaymentTypeEmoji(type: string): string {
    const typeEmojis = {
      'paypal': 'üì±',
      'mpesa': '',
      'credit_card': 'üí≥',
      'debit_card': 'üí≥'
    };
    return typeEmojis[type.toLowerCase()] || 'üí≥';
  }


  private formatDriverDashboard(driver: any, dashboard: any): string {
    const statusIcon = driver.isAvailable ? 'üü¢' : 'üî¥';
    const ratingStars = '‚≠ê'.repeat(Math.floor(driver.rating || 0));
    
    return `üöó **Driver Dashboard**

**Current Status:** ${statusIcon} ${driver.isAvailable ? 'Available' : 'Offline'}
**Your Rating:** ${ratingStars} ${driver.rating || 'Not rated'}/5

**üìä Weekly Performance:**
üí∞ Earnings: $${dashboard.weeklyStats.totalEarnings}
üöó Completed Trips: ${dashboard.weeklyStats.totalDrives}
üìà Growth: ${dashboard.weeklyStats.percentageChange > 0 ? '+' : ''}${dashboard.weeklyStats.percentageChange}%

**üéØ Performance Metrics:**
‚≠ê Overall Rating: ${dashboard.performanceMetrics.overallRating}/5
üë• Customer Experience: ${dashboard.performanceMetrics.customerExperience}%
‚è∞ Time Consciousness: ${dashboard.performanceMetrics.timeConsciousness}%
üòä Friendliness: ${dashboard.performanceMetrics.friendliness}%

**üöô Vehicle Information:**
${dashboard.vehicle ? `üöô ${dashboard.vehicle.model} - ${dashboard.vehicle.plateNumber}` : '‚ùå No vehicle registered'}

**Quick Actions:**
üîó Full Dashboard: /dashboard
üìä Detailed Analytics: /dashboard
üöó Start Driving: /bookings
üì± Mobile Driver App: Download now`;
  }

  private formatBasicDriverInfo(driver: any): string {
    const statusIcon = driver.isAvailable ? 'üü¢' : 'üî¥';
    const ratingStars = '‚≠ê'.repeat(Math.floor(driver.rating || 0));
    
    return `üöó **Driver Dashboard** (Basic View)

**Status:** ${statusIcon} ${driver.isAvailable ? 'Available' : 'Offline'}
**Rating:** ${ratingStars} ${driver.rating || 'Not rated'}/5

**Quick Actions:**
üîó View Bookings: /bookings
üìä Performance Stats: /dashboard
‚öôÔ∏è Settings: /settings
üìû Support: /support`;
  }

  private async handleReviews(userId: number): Promise<string> {
    const reviews = await this.reviewRepository.find({
      take: 5,
      relations: ['user'],
    });

    if (reviews.length === 0) {
      return `You haven't written any reviews yet.

‚≠ê [Leave a Review](/review)
üìã [View All Reviews](/review)`;
    }

    let response = `**Your Recent Reviews:**\n`;
    reviews.forEach((review, index) => {
      response += `${index + 1}. **${review.rating}/5** - ${review.comment || 'No comment'}\n`;
    });

    response += `\n**Quick Actions:**
‚≠ê [Leave a New Review](/review)
üìã [View All Reviews](/review)`;

    return response;
  }

  private async handleProfile(userId: number): Promise<string> {
    const user = await this.userRepository.findOne({ where: { userId: userId } }); 
    
    if (!user) {
      return `User profile not found. Please contact support.

üîó [Contact Support](/support)
üè† [Return to Dashboard](/dashboard)`;
    }

    return `**Your Profile** üë§
üìß **Email:** ${user.email}
üë§ **Name:** ${user.firstName} ${user.lastName}
üì± **Phone:** ${user.phone || 'Not provided'}
üéÇ **Member Since:** ${user.created_at ? new Date(user.created_at).toLocaleDateString() : 'Unknown'}

**Quick Actions:**
‚öôÔ∏è [Edit Profile](/account)
üè† [Dashboard](/dashboard)`;
  }

  private async handleHelpQuery(userId: number): Promise<string> {
    return `**How can I help you?** ü§ù

**I can assist you with:**
üöó **Bookings** - View, create, or manage your rides
üí≥ **Payments** - Manage payment methods and billing
üë§ **Profile** - Update your account information
‚≠ê **Reviews** - Leave feedback or view your reviews
üöô **Driver Info** - Driver dashboard and earnings (if you're a driver)

**Quick Commands:**
‚Ä¢ Type "bookings" to see your recent rides
‚Ä¢ Type "payment" to manage payment methods
‚Ä¢ Type "profile" to view your account
‚Ä¢ Type "help" anytime for assistance

**Need more help?**
üìû [Contact Support](/support)
‚ùì [FAQ](/support)
üí¨ [Live Chat](/support)`;
  }

  private async handleCancelBooking(userId: number): Promise<string> {
    const activeBookings = await this.bookingRepository.find({
      where: { 
        user: { userId: userId },
        status: Status.Requested 
      },
      order: { pickup_time: 'DESC' },
      take: 5,
      relations: ['user', 'driver'],
    });

    if (activeBookings.length === 0) {
      return `You don't have any active bookings to cancel.

üìã [View All Bookings](/bookings)
üÜï [Create New Booking](/create)`;
    }

    let response = `**Bookings Available for Cancellation:**\n\n`;
    activeBookings.forEach((booking, index) => {
      response += `${index + 1}. **Booking #${booking.id}**
üìç From: ${booking.start_latitude}, ${booking.start_longitude}
üìç To: ${booking.end_latitude}, ${booking.end_longitude}
üí∞ Fare: $${booking.fare || 0}
üîó [Cancel Booking](/bookings)\n\n`;
    });

    response += `**Note:** Cancellation policies may apply depending on timing.
üìã [View Cancellation Policy](/policy/cancellation)`;

    return response;
  }

  private async handleGreeting(userId: number): Promise<string> {
    const user = await this.userRepository.findOne({ where: { userId: userId } });
    const userName = user ? `${user.firstName || 'there'}` : 'there';

    const hour = new Date().getHours();
    let greeting = 'Hello';
    
    if (hour < 12) greeting = 'Good morning';
    else if (hour < 18) greeting = 'Good afternoon';
    else greeting = 'Good evening';

    return `${greeting}, ${userName}! üëã

Welcome to your ride-sharing assistant! I'm here to help you with:

üöó **Book a ride** - Find and book your next trip
üìã **View bookings** - Check your ride history
üí≥ **Manage payments** - Update payment methods
üë§ **Account settings** - Manage your profile
‚≠ê **Reviews** - Leave feedback

**What would you like to do today?**

Type anything like "book a ride", "my bookings", or "help" to get started!`;
  }

  private async handleAnalytics(userId: number, message: string): Promise<string> {
    try {
      if (message.includes('driver') || message.includes('earnings')) {
        const driver = await this.driverRepository.findOne({
          where: { user: { userId: userId } },
        });

        if (driver) {
          if (typeof driver.driver_id === 'undefined') {
            return `Driver information is incomplete. Please update your driver profile.

üöó [Update Driver Profile](/driver)
üìã [View Driver Dashboard](/dashboard)`;
          }
          const driverDashboard = await this.analyticsService.getDriverDashboard(driver.driver_id);
          
          return `**üìä Your Driver Analytics**

**Weekly Performance:**
üöó Completed Rides: ${driverDashboard.weeklyStats.totalDrives}
üí∞ Total Earnings: $${driverDashboard.weeklyStats.totalEarnings}
üìà Growth: ${driverDashboard.weeklyStats.percentageChange > 0 ? '+' : ''}${driverDashboard.weeklyStats.percentageChange}% vs last week

**Performance Metrics:**
‚≠ê Overall Rating: ${driverDashboard.performanceMetrics.overallRating}/5
üë• Customer Experience: ${driverDashboard.performanceMetrics.customerExperience}%
‚è∞ Time Consciousness: ${driverDashboard.performanceMetrics.timeConsciousness}%
üòä Friendliness: ${driverDashboard.performanceMetrics.friendliness}%

**Top Destinations:**
${driverDashboard.topDestinations.slice(0, 3).map((dest, i) => 
  `${i + 1}. ${dest.destination} - $${dest.price} (${dest.count} trips)`
).join('\n')}

üîó [View Full Analytics](/dashboard)`;
        }
      }

      const customerDashboard = await this.analyticsService.getCustomerDashboard(userId);
      
      return `**üìä Your Travel Analytics**

**Travel Summary:**
üöó Total Bookings: ${customerDashboard.totalBookings}
üí∞ Total Spent: $${customerDashboard.totalExpenditure}

**Weekly Trends:**
üìà This Week: ${customerDashboard.weeklyTrends.currentWeek} rides
üìâ Last Week: ${customerDashboard.weeklyTrends.previousWeek} rides
${customerDashboard.weeklyTrends.percentageChange > 0 ? 'üìà' : 'üìâ'} Change: ${customerDashboard.weeklyTrends.percentageChange}%

**Ride Time Distribution:**
‚ö° <10 mins: ${customerDashboard.rideTimeDistribution['<10 mins']} rides
üïê 10-30 mins: ${customerDashboard.rideTimeDistribution['10-30 mins']} rides
üïë >30 mins: ${customerDashboard.rideTimeDistribution['>30 mins']} rides

üîó [View Full Dashboard](/dashboard)
üìä [View Detailed Analytics](/analytics)`;

    } catch (error) {
      this.logger.error('Analytics error:', error);
      return `I'm having trouble accessing your analytics right now.

**What I can help you with:**
üìä View travel statistics
üí∞ Check spending summaries
üöó Driver performance metrics

Please try again or [contact support](/support) if the issue persists.`;
    }
  }

  private async handleSystemStatus(): Promise<string> {
    try {
      const systemStatus = await this.analyticsService.getSystemStatus();
      
      return `**üåê System Status** - ${systemStatus.systemHealth.toUpperCase()}

**Current Activity:**
üöó Active Bookings: ${systemStatus.activeBookings}
üë®‚Äçüöó Available Drivers: ${systemStatus.availableDrivers}
üìç System Health: ${systemStatus.systemHealth}
üïê Last Update: ${new Date(systemStatus.lastUpdate).toLocaleTimeString()}

**Quick Actions:**
üöó [Book a Ride](/create)
üë®‚Äçüöó [Become a Driver](/driver-registration)
üìä [View Analytics](/dashboard)

*System monitoring is active 24/7*`;

    } catch (error) {
      return `**üåê System Status** - CHECKING

I'm having trouble accessing the system status right now.

**Try these instead:**
üöó [Book a Ride](/create)
üìû [Contact Support](/support)
üè† [Return to Dashboard](/dashboard)`;
    }
  }

  private async handleContextualResponse(userId: number, message: string): Promise<string> {
    const context = this.conversationContext.get(userId) || [];
    const lowerMessage = message.toLowerCase();
    
    // Handle travel-related queries that weren't caught earlier
    if (lowerMessage.includes('get to') || lowerMessage.includes('travel') || lowerMessage.includes('go to')) {
      return this.handleLocationBasedBooking(userId, message);
    }
    
    if (lowerMessage.includes('thank') || lowerMessage.includes('thanks')) {
      return `You're welcome! üòä Is there anything else I can help you with?

**Quick Actions:**
üöó [Book a Ride](/create)
üìã [View Bookings](/bookings)
üìä [View Analytics](/dashboard)
üë§ [Profile](/account)`;
    }
    
    if (lowerMessage.includes('earnings') || lowerMessage.includes('money') || lowerMessage.includes('income')) {
      return `I can help you check your earnings! üí∞

**Available Options:**
üìä Type "analytics" to see your detailed statistics
üöó Type "driver" to view your driver dashboard
üí≥ Type "payment" to manage payment methods

**Quick Links:**
üìà [Driver Analytics](/dashboard)
üí∞ [Earnings Report](/dashboard)`;
    }

    if (lowerMessage.includes('performance') || lowerMessage.includes('rating') || lowerMessage.includes('score')) {
      return `I can show you your performance metrics! ‚≠ê

**Check Your Performance:**
üìä Type "analytics" for detailed performance stats
‚≠ê Type "reviews" to see your recent reviews
üöó Type "driver" for your driver dashboard

**Performance Areas:**
üë• Customer Experience
‚è∞ Time Consciousness  
üòä Friendliness Score`;
    }
    
    if (lowerMessage.includes('problem') || lowerMessage.includes('issue') || lowerMessage.includes('error')) {
      return `I'm sorry to hear you're experiencing an issue. Let me help you resolve it.

**Common Solutions:**
üîÑ Try refreshing the page
üì± Check your internet connection
üÜï Try creating a new booking
üìä Check system status with "system status"

**Still need help?**
üìû [Contact Support](/support)
üí¨ [Live Chat](/support)
üìß [Email Support](mailto:support@rideshare.com)`;
    }
    
    return `I'm here to help! ü§ù

**I understand you might need:**
üöó **Immediate ride booking** - Type "book a ride from [location] to [destination]"
ÔøΩ **Location help** - Tell me where you are and where you need to go
üÜò **Emergency assistance** - Type "emergency" for urgent help

**Quick Examples:**
‚Ä¢ "I need to get from Thika to Nairobi"
‚Ä¢ "Book a ride to the airport"
‚Ä¢ "I'm stuck and need help"

**Or try:**
üí¨ Type "help" for full assistance menu
`;
  }

  private getErrorResponse(): string {
    return `I apologize, but I encountered an error while processing your request. üòî

**Please try:**
üîÑ Asking your question again
üì± Refreshing the page
‚è∞ Waiting a moment and retrying

**Need immediate help?**
üìû [Contact Support](/support)
üí¨ [Live Chat](/support)

I'm here to help once the issue is resolved!`;
  }

  private async handleRoleSwitching(userId: number, message: string): Promise<string> {
    const lowerMessage = message.toLowerCase();
    
    if (lowerMessage.includes('my role') || lowerMessage.includes('current role')) {
      try {
        const roleInfo = await this.roleSwitchingService.getCurrentRole(userId);
        
        return `üë§ **Your Current Role Status**

**Active Role:** ${roleInfo.activeRole.toUpperCase()} Mode
**Available Roles:** ${roleInfo.availableRoles.map(r => r.charAt(0).toUpperCase() + r.slice(1)).join(', ')}

**Role Switching Options:**
${roleInfo.canSwitchToDriver ? 'üöó Switch to Driver: Type "switch to driver"' : ''}
${roleInfo.canSwitchToCustomer ? 'üõçÔ∏è Switch to Customer: Type "switch to customer"' : ''}
${roleInfo.requiresDriverSetup ? 'üìù Complete Driver Setup: /driver-registration' : ''}

**Quick Actions:**
üìä View Dashboard: /dashboard
‚öôÔ∏è Account Settings: /profile
üîÑ Enable Driver Mode: Type "enable driver" (if not available)`;

      } catch (error) {
        return `‚ùå Unable to retrieve your role information. Please try again or contact support.`;
      }
    }
    
    if (lowerMessage.includes('switch to driver') || lowerMessage.includes('become driver')) {
      try {
        const result = await this.roleSwitchingService.switchToDriver(userId);
        
        if (result.success) {
          if (result.requiresDriverSetup) {
            return `üöó **Driver Mode Setup Required**

To start driving, you need to complete your driver profile:

**Required Steps:**
üìù Complete Driver Application: /driver-registration

**Once verified, you can:**
üîÑ Switch between roles anytime
üí∞ Start earning as a driver
üì± Access driver dashboard

**Current Status:** Customer Mode
üîó [Start Driver Registration](/driver-registration)`;
          } else {
            return `‚úÖ **Successfully Switched to Driver Mode**

üöó You're now in driver mode and ready to accept rides!

**Driver Dashboard:**
üìä View Earnings: /dashboard
üìã View Bookings: /bookings

**Quick Actions:**
üü¢ Go Online: /dashboard
üì± Driver App: Download now
üîÑ Switch to Customer: Type "switch to customer"

**Available Roles:** ${result.availableRoles?.join(', ')}`;
          }
        } else {
          return `‚ö†Ô∏è ${result.message}

**Available Options:**
${result.availableRoles?.includes(Role.DRIVER) ? 'üöó Complete driver setup first' : 'üìù Enable driver mode: Type "enable driver"'}
üîÑ Check current role: Type "my role"`;
        }
      } catch (error) {
        return `‚ùå Unable to switch to driver mode. ${error.message || 'Please try again or contact support.'}`;
      }
    }
    
    if (lowerMessage.includes('switch to customer') || lowerMessage.includes('customer mode')) {
      try {
        const result = await this.roleSwitchingService.switchToCustomer(userId);
        
        if (result.success) {
          return `‚úÖ **Successfully Switched to Customer Mode**

üõçÔ∏è You're now in customer mode!

**Quick Actions:**
üöó Book a Ride: /create
üìã View My Bookings: /bookings
üìç Manage Locations: /drive

**Need to drive again?**
üîÑ Type "switch to driver" anytime
üí∞ Resume earning when ready

**Available Roles:** ${result.availableRoles?.join(', ')}`;
        } else {
          return `‚ö†Ô∏è ${result.message}

**Available Options:**
üîÑ Check current role: Type "my role"
üìû Contact Support: /support`;
        }
        
      } catch (error) {
        return `‚ùå Unable to switch to customer mode. ${error.message || 'Please try again or contact support.'}`;
      }
    }
    
    if (lowerMessage.includes('enable driver')) {
      try {
        const result = await this.roleSwitchingService.enableDriverMode(userId);
        
        return `‚úÖ **Driver Mode ${result.success ? 'Enabled' : 'Status'}**

${result.message}

**Next Steps:**
${result.requiresDriverSetup ? 'üìù Complete Driver Registration: /driver/register' : 'üöó Switch to Driver Mode: Type "switch to driver"'}
üîÑ Check available roles: Type "my role"

**Available Roles:** ${result.availableRoles?.join(', ')}`;
      } catch (error) {
        return `‚ùå Unable to enable driver mode. Please contact support.`;
      }
    }
    
    return "";
  }
}